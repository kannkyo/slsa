---
language: ja
---
# SLSA 来歴

このページでは、より大きな [in-toto認証] フレームワークの中で適合する SLSA 来歴の述語について説明します。

Type URI: https://slsa.dev/lang/ja/provenance/v0.1

Version: 0.1.1

<details>
<summary>Note about 0.x versions</summary>

1.0になるまでは、0.xバージョンを定期的に繰り返していくことになります。0.xの間は、デザインに対するフィードバックを早く得るために、より小さく、より速いリリースに傾いています。
1.0以降は、速報性のある変更の頻度を制限する予定です。

これを管理しやすくするために、以下のことを推奨します。

-   来歴ジェネレーターは、実装時に最新の0.xバージョンを選択し、1.0まではアップグレードする理由がない限り、そのバージョンを維持します。
-   来歴コンシューマーは、すべての既知のバージョンを受け入れ、それらの間で内部的に変換します。

</details>

<details>
<summary>Other versions of this spec</summary>

-   [0.2]
-   **0.1**

</details>

## 目的

アーティファクトまたはアーティファクトのセットがどのように作成されたかを説明します。

この述語は、SLSA の[来歴要件]を満たすために推奨される方法です。

## モデル

来歴とは、あるエンティティ（`builder`）が、他のアーティファクトを入力（`materials`）として、ある `recipe` を実行することで、1 つ以上のソフトウェアアーティファクト（[Statement]の `subject`）を生成したという claim のことです。
builder は、来歴を忠実に記録していると信頼されています。
builder を信頼する以外の選択肢はありません。
しかし、builder は、外部のおそらく信頼されていないエンティティの要求に応じて、この操作を行ったかもしれない。
これらの信頼できないパラメータは、レシピの `entryPoint` や `arguments` 、そして `materials` の一部に含まれています。
最後に、ビルドは[再現性][Reproducible]ために必要な外部からのコントロールを受けない様々な環境パラメータ(`environment`)に依存していたかもしれません。

具体的な例については、[例](#example)を参照してください。

![Model Diagram](../../../images/provenance/v0.1/provenance.svg)

## スキーマ

```jsonc
{
  // Standard attestation fields:
  "_type": "https://in-toto.io/Statement/v0.1",
  "subject": [{ ... }],

  // Predicate:
  "predicateType": "https://slsa.dev/provenance/v0.1",
  "predicate": {
    "builder": {
      "id": "<URI>"
    },
    "recipe": {
      "type": "<URI>",
      "definedInMaterial": /* integer */,
      "entryPoint": "<STRING>",
      "arguments": { /* object */ },
      "environment": { /* object */ }
    },
    "metadata": {
      "buildInvocationId": "<STRING>",
      "buildStartedOn": "<TIMESTAMP>",
      "buildFinishedOn": "<TIMESTAMP>",
      "completeness": {
        "arguments": true/false,
        "environment": true/false,
        "materials": true/false
      },
      "reproducible": true/false
    },
    "materials": [
      {
        "uri": "<URI>",
        "digest": { /* DigestSet */ }
      }
    ]
  }
}
```

### パース規約

この述語は、in-toto 認証の [パース規約] に従います。

概要：

-   消費者は認識されないフィールドを無視しなければなりません(MUST)。
-   `predicateTypeURI` は、メジャーバージョン番号が含んでおり、後方互換性のない変更があるたびに、常に変化します。
-   マイナーバージョンの変更は、常に下位互換性があり、「単調」です。このような変更は、`predicateType` を更新しません。
-   プロデューサーは、URI であるフィールド名を使用して拡張フィールドを追加できます(MAY)。

### フィールド

_NOTE: このセクションでは、`predicate`の中のフィールドについて説明します。
`Subject`などの他のトップレベルのフィールドの説明については、[Statement]を参照してください。_

<a id="builder"></a>
`builder` _object, required_

> Identifies the entity that executed the recipe, which is trusted to have
> correctly performed the operation and populated this provenance.
>
> The identity MUST reflect the trust base that consumers care about. How
> detailed to be is a judgement call. For example, [GitHub Actions] supports
> both GitHub-hosted runners and self-hosted runners. The GitHub-hosted runner
> might be a single identity because, it's all GitHub from the consumer's
> perspective. Meanwhile, each self-hosted runner might have its own identity
> because not all runners are trusted by all consumers.
>
> Consumers MUST accept only specific (signer, builder) pairs. For example, the
> "GitHub" can sign provenance for the "GitHub Actions" builder, and "Google"
> can sign provenance for the "Google Cloud Build" builder, but "GitHub" cannot
> sign for the "Google Cloud Build" builder.
>
> Design rationale: The builder is distinct from the signer because one signer
> may generate attestations for more than one builder, as in the GitHub Actions
> example above. The field is required, even if it is implicit from the signer,
> to aid readability and debugging. It is an object to allow additional fields
> in the future, in case one URI is not sufficient.

<a id="builder.id"></a>
`builder.id` _string ([TypeURI]), required_

> URI indicating the builder's identity.

<a id="recipe"></a>
`recipe` _object, optional_

> Identifies the configuration used for the build. When combined with
> `materials`, this SHOULD fully describe the build, such that re-running this
> recipe results in bit-for-bit identical output (if the build is
> [reproducible]).
>
> MAY be unset/null if unknown, but this is DISCOURAGED.

<a id="recipe.type"></a>
`recipe.type` _string ([TypeURI]), required_

> URI indicating what type of recipe was performed. It determines the meaning of
> `recipe.entryPoint`, `recipe.arguments`, `recipe.environment`, and
> `materials`.

<a id="recipe.definedInMaterial"></a>
`recipe.definedInMaterial` _integer, optional_

> Index in `materials` containing the recipe steps that are not implied by
> `recipe.type`. For example, if the recipe type were "make", then this would
> point to the source containing the Makefile, not the `make` program itself.
>
> Omit this field (or use null) if the recipe doesn't come from a material.
>
> TODO: What if there is more than one material?

<a id="recipe.entryPoint"></a>
`recipe.entryPoint` _string, optional_

> String identifying the entry point into the build. This is often a path to a
> configuration file and/or a target label within that file. The syntax and
> meaning are defined by `recipe.type`. For example, if the recipe type were
> "make", then this would reference the directory in which to run `make` as well
> as which target to use.
>
> Consumers SHOULD accept only specific `recipe.entryPoint` values. For example,
> a policy might only allow the "release" entry point but not the "debug" entry
> point.
>
> MAY be omitted if the recipe type specifies a default value.
>
> Design rationale: The `entryPoint` is distinct from `arguments` to make it
> easier to write secure policies without having to parse `arguments`.

<a id="recipe.arguments"></a>
`recipe.arguments` _object, optional_

> Collection of all external inputs that influenced the build on top of
> `recipe.definedInMaterial` and `recipe.entryPoint`. For example, if the recipe
> type were "make", then this might be the flags passed to `make` aside from the
> target, which is captured in `recipe.entryPoint`.
>
> Consumers SHOULD accept only "safe" `recipe.arguments`. The simplest and
> safest way to achieve this is to disallow any `arguments` altogether.
>
> This is an arbitrary JSON object with a schema is defined by `recipe.type`.
>
> This is considered to be incomplete unless `metadata.completeness.arguments`
> is true. Unset or null is equivalent to empty.

<a id="recipe.environment"></a>
`recipe.environment` _object, optional_

> Any other builder-controlled inputs necessary for correctly evaluating the
> recipe. Usually only needed for [reproducing][reproducible] the build but not
> evaluated as part of policy.
>
> This SHOULD be minimized to only include things that are part of the public
> API, that cannot be recomputed from other values in the provenance, and that
> actually affect the evaluation of the recipe. For example, this might include
> variables that are referenced in the workflow definition, but it SHOULD NOT
> include a dump of all environment variables or include things like the
> hostname (assuming hostname is not part of the public API).
>
> This is an arbitrary JSON object with a schema is defined by `recipe.type`.
>
> This is considered to be incomplete unless `metadata.completeness.environment`
> is true. Unset or null is equivalent to empty.

<a id="metadata"></a>
`metadata` _object, optional_

> Other properties of the build.

<a id="metadata.buildInvocationId"></a>
`metadata.buildInvocationId` _string, optional_

> Identifies this particular build invocation, which can be useful for finding
> associated logs or other ad-hoc analysis. The exact meaning and format is
> defined by `builder.id`; by default it is treated as opaque and
> case-sensitive. The value SHOULD be globally unique.

<a id="metadata.buildStartedOn"></a>
`metadata.buildStartedOn` _string ([Timestamp]), optional_

> The timestamp of when the build started.

<a id="metadata.buildFinishedOn"></a>
`metadata.buildFinishedOn` _string ([Timestamp]), optional_

> The timestamp of when the build completed.

<a id="metadata.completeness"></a>
`metadata.completeness` _object, optional_

> Indicates that the `builder` claims certain fields in this message to be
> complete.

<a id="metadata.completeness.arguments"></a>
`metadata.completeness.arguments` _boolean, optional_

> If true, the `builder` claims that `recipe.arguments` is complete, meaning
> that all external inputs are propertly captured in `recipe`.

<a id="metadata.completeness.environment"></a>
`metadata.completeness.environment` _boolean, optional_

> If true, the `builder` claims that `recipe.environment` is claimed to be
> complete.

<a id="metadata.completeness.materials"></a>
`metadata.completeness.materials` _boolean, optional_

> If true, the `builder` claims that `materials` is complete, usually through
> some controls to prevent network access. Sometimes called "hermetic".

<a id="metadata.reproducible"></a>
`metadata.reproducible` _boolean, optional_

> If true, the `builder` claims that running `recipe` on `materials` will
> produce bit-for-bit identical output.

<a id="materials"></a>
`materials` _array of objects, optional_

> The collection of artifacts that influenced the build including sources,
> dependencies, build tools, base images, and so on.
>
> This is considered to be incomplete unless `metadata.completeness.materials`
> is true. Unset or null is equivalent to empty.

<a id="materials.uri"></a>
`materials[*].uri` _string ([ResourceURI]), optional_

> The method by which this artifact was referenced during the build.
>
> TODO: Should we differentiate between the "referenced" URI and the "resolved"
> URI, e.g. "latest" vs "3.4.1"?
>
> TODO: Should wrap in a `locator` object to allow for extensibility, in case we
> add other types of URIs or other non-URI locators?

<a id="materials.digest"></a>
`materials[*].digest` _object ([DigestSet]), optional_

> Collection of cryptographic digests for the contents of this artifact.

<a id="example"></a>

## 例

WARNING：これはデモンストレーションのみを目的としています。

例えば、ビルダーが `example-1.2.3.tar.gz` をダウンロードして解凍し、 `make -C src foo CFLAGS=O3` を実行して、ハッシュ `5678...` のファイルを得たとします。
そうすると、証明書は次のようになります。

```jsonc
{
  "_type": "https://in-toto.io/Statement/v0.1",
  // Output file; name is "_" to indicate "not important".
  "subject": [{"name": "_", "digest": {"sha256": "5678..."}}],
  "predicateType": "https://slsa.dev/provenance/v0.1",
  "predicate": {
    "builder": { "id": "mailto:person@example.com" },
    "recipe": {
      "type": "https://example.com/Makefile",
      "definedInMaterial": 0,                 // material containing the Makefile
      "entryPoint": "src:foo",                // target "foo" in directory "src"
      "arguments": {"CFLAGS": "-O3"}          // extra args to `make`
    },
    "materials": [{
      "uri": "https://example.com/example-1.2.3.tar.gz",
      "digest": {"sha256": "1234..."}
    }]
  }
}
```

## More examples

### GitHub Actions

WARNING：これはデモンストレーションのみを目的としています。
GitHub Actions チームは、この設計をまだレビューまたは承認しておらず、まだ実装されていません。詳細は変更される場合があります！

GitHub が来歴を生成するものであり、ランナーが GitHub でホストされている場合、ビルダーは次のようになります。

```json
"builder": {
  "id": "https://github.com/Attestations/GitHubHostedActions@v1"
}
```

セルフホスト型のランナーです。
まだサポートされていません。
どのシステムがランナーをホストしているかを表すURIスキームを考えるか、`builder`に追加のプロパティを追加する必要があります。

GitHub Actions ワークフロー:

```jsonc
"recipe": {
  // Build steps were defined in a GitHub Actions Workflow file ...
  "type": "https://github.com/Attestations/GitHubActionsWorkflow@v1",
  // ... in the git repo described by `materials[0]` ...
  "definedInMaterial": 0,
  // ... at the path .github/workflows/build.yaml, using the job "build".
  "entryPoint": "build.yaml:build",
  // The only possible user-defined parameters that can affect the build are the
  // "inputs" to a workflow_dispatch event. This is unset/null for all other
  // events.
  "arguments": {
    "inputs": { ... }
  },
  // Other variables that are required to reproduce the build and that cannot be
  // recomputed using existing information. (Documentation would explain how to
  // recompute the rest of the fields.)
  "environment": {
    // The architecture of the runner.
    "arch": "amd64",
    // Environment variables. These are always set because it is not possible
    // to know whether they were referenced or not.
    "env": {
      "GITHUB_RUN_ID": "1234",
      "GITHUB_RUN_NUMBER": "5678",
      "GITHUB_EVENT_NAME": "push"
    },
    // The context values that were referenced in the workflow definition.
    // Secrets are set to the empty string.
    "context": {
      "github": {
        "run_id": "abcd1234"
      },
      "runner": {
        "os": "Linux",
        "temp": "/tmp/tmp.iizj8l0XhS",
      }
    }
  }
}
"materials": [{
  // The git repo that contains the build.yaml referenced above.
  "uri": "git+https://github.com/foo/bar.git",
  // The resolved git commit hash reflecting the version of the repo used
  // for this build.
  "digest": {"sha1": "abc..."}
}]
```

### Google Cloud Build

WARNING: これはデモンストレーションのためのものです。
Google Cloud Buildチームは、このデザインをまだレビューまたは承認しておらず、実装もされていません。
詳細は変更される可能性があります。

実績を生成するのがGoogleで、ワーカーがGoogleでホスティングされている場合、ビルダーは以下のようになります。

```json
"builder": {
  "id": "https://cloudbuild.googleapis.com/GoogleHostedWorker@v1"
}
```

カスタムワーカーです。
まだサポートされていません。
どのシステムがワーカーをホストしているかを表すURIスキームを考えるか、`builder`に追加のプロパティを追加する必要があります。

#### Cloud Build config-as-code

ここでは、`entryPoint`は、CloudBuildの[BuildTrigger](https://cloud.google.com/build/docs/api/reference/rest/v1/projects.triggers)の`filename`を参照しています。

```jsonc
"recipe": {
  // Build steps were defined in a cloudbuild.yaml file ...
  "type": "https://cloudbuild.googleapis.com/CloudBuildYaml@v1",
  // ... in the git repo described by `materials[0]` ...
  "definedInMaterial": 0,
  // ... at the path path/to/cloudbuild.yaml.
  "entryPoint": "path/to/cloudbuild.yaml",
  // The only possible user-defined parameters that can affect a BuildTrigger
  // are the subtitutions in the BuildTrigger.
  "arguments": {
    "substitutions": {...}
  }
}
"materials": [{
  // The git repo that contains the cloudbuild.yaml referenced above.
  "uri": "git+https://source.developers.google.com/p/foo/r/bar",
  // The resolved git commit hash reflecting the version of the repo used
  // for this build.
  "digest": {"sha1": "abc..."}
}]
```

#### クラウドビルドRPC

ここでは、トリガーまたは RPC で定義されたステップをリストします。

```jsonc
"recipe": {
  // Build steps were provided as an argument. No `definedInMaterial` or
  // `entryPoint`.
  "type": "https://cloudbuild.googleapis.com/CloudBuildSteps@v1",
  "arguments": {
    // The steps that were performed. (Format TBD.)
    "steps": [...],
    // The substitutions in the build trigger.
    "substitutions": {...}
    // TODO: Any other arguments?
  }
}
```

### コマンドを明示的に実行する

WARNING：これは概念実証にすぎません。まだ標準化されていません。

任意のコマンドの実行：

```jsonc
"recipe": {
  // There was no entry point, and the commands were run in an ad-hoc fashion.
  // There is no `definedInMaterial` or `entryPoint`.
  "type": "https://example.com/ManuallyRunCommands@v1",
  "arguments": {
    // The list of commands that were executed.
    "commands": [
      "tar xvf foo-1.2.3.tar.gz",
      "cd foo-1.2.3",
      "./configure --enable-some-feature",
      "make foo.zip"
    ],
    // Indicates how to parse the strings in `commands`.
    "shell": "bash"
  }
}
```

## 変更履歴

-   「slsa.dev/provenance」に名前が変更されました
-   0.1.1: `metadata.buildInvocationId` を追加
-   0.1:「in-toto.io/Provenance」という名前の初期バージョン

[0.1]: v0.1.md
[0.2]: v0.2.md
[DigestSet]: https://github.com/in-toto/attestation/blob/main/spec/field_types.md#DigestSet
[GitHub Actions]: #github-actions
[Reproducible]: https://reproducible-builds.org
[ResourceURI]: https://github.com/in-toto/attestation/blob/main/spec/field_types.md#ResourceURI
[SLSA]: https://slsa.dev
[Statement]: https://github.com/in-toto/attestation/blob/main/spec/README.md#statement
[Timestamp]: https://github.com/in-toto/attestation/blob/main/spec/field_types.md#Timestamp
[TypeURI]: https://github.com/in-toto/attestation/blob/main/spec/field_types.md#TypeURI
[in-toto認証]: https://github.com/in-toto/attestation
[パース規約]: https://github.com/in-toto/attestation/blob/main/spec/README.md#parsing-rules
[来歴要件]: ../requirements.md#provenance-requirements
